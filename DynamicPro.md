### Dynamic Programming
动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。

动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。不像搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。

但是我们可以通过对若干有代表性的问题的动态规划算法进行分析、讨论，逐渐学会并掌握这一设计方法。

#### 基本思想
与分治法类似：本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解

与分治法不同：动态规划求解的问题，经分解得到子问题往往不是互相独立的

分治法的问题：分解得到的子问题数目太多，有些子问题被重复计算了很多次

解决方法：如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中

基本思路：具体的动态规划算法多种多样，但它们具有相同的填表格式

#### 基本种类
动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。
举例：
+ 线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；
+ 区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；
+ 树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；
+ 背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（同济ACM第1132题）等；
+ 应用实例：最短路径问题 ，项目管理，网络流优化等；

#### 适用条件
任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。

+ 1.最优化原理（最优子结构性质）：简而言之，一个最优化策略的子策略总是最优的。
+ 2.无后效性：每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。
+ 3.子问题的重叠性：动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。

#### 基本术语
+ 状态
+ 状态转移方程
+ 最优子结构
+ 重叠子问题

动态规划的核心是状态和状态转移方程，但是有了状态转移方程之后，应该如何计算呢？

+ 方法1：递归计算，但是时间效率低，因为重复计算。这个就是用回溯法进行计算，但是可以剪枝减少计算量。
+ 方法2：递推计算，递推计算的关键是边界和计算顺序。在多数情况下，递推法的时间复杂度是：状态总数 \* 每个状态的决策个数 \* 决策时间。
+ 方法3：记忆化搜索，可以不必事先确定各状态的计算顺序，但需要记录每个状态“是否已经计算过”。

#### 一些心得

求解动态规划问题，首先要确定三种变量，求解量（未知）、状态量（变量，可能有好几个）、选择量（已知）。
还有就是规划方向:0 -> i 或 i -> n;
在这就是计算方向：0 -> j 或 C -> j;
可以尝试不同的方式方法来写状态转移方程，但是一般写自己最熟悉的方法。

#### DAG上的动态规划
有向无环图上的动态规划是学习动态规划的基础。很多问题都可以转化为DAG上的最长路、最短路或路径计数问题。

##### DAG模型
+ 嵌套矩形问题

** 最长路及其字典序 **

状态转移方程：$d(i) = max{d(j) + 1 | (i,j) \in E}$

邻接矩阵G把图建立出来，接下来写记忆化搜索程序：

```C
int dp(int i){
  int& ans = d[i];
  if(ans > 0) return ans;
  for(int j = 1; j <= n; j++){
    if(G[i][j]) ans = max(ans, dp(j + 1));
    return ans;
  }
}
```
输出字典序：

```C
void print_ans(int i){
  printf("d ", i);
  for(int j = 1; j <= n; j++) if (G[i][j] && d[i] == d[j] + 1) {
    print_ans(j);
    break;
  }
}
```

+ 硬币问题

** 固定终点的最长路和最短路 **

d[i]的确切含义变为“从结点i出发到结点0的最长路径长度”，记忆化搜索来求：
```C
int dp(int S){
  int$ ans = d[S];
  if(ans != -1) return ans;
  ans = -(1 << 30);
  for(int i = 1; i <= n; i++) if(S >= V[i]) ans = max(ans, dp(S - V[i]) + 1);
  return ans;
}
```
用更加方便的方法递推：
```C
minv[0] = maxv[0] = 0;
for(int i = 1; i <= S; i++){
  minv[i] = INF;maxv[i] = -INF;
}
for(int i = 1; i <= S; i++){
  for(int j = 1; j <= n; j++){
    minv[i] = min(minv[i], minv[i - V[j]] + 1);
    maxv[i] = max(maxv[i], maxv[i - V[i]] + 1);
  }
}
```

##### 小结与应用
由于DAG最长（短）路的特殊性，有两种“对称”的状态定义方式：
+ 状态1： 设d(i)为从i出发的最长路，则d(i) = max{d(j) + 1| (i,j)}
+ 状态2： 设d(i)为以i结束的最长路，则d(i) = max{d(j) + 1| (j,i)}

传统的递推法可以表示成“对于每个状态i，计算f(i)”,或者称为“填表法”。这需要对于每个状态i，找到f(i)依赖的所有状态，在某些时候并不方便。

另一种方法是“对于每个状态i，更新f(i)所影响到的状态”，或者称为“刷表法”，有时比填表法方便。但需要注意的是，只有当每个状态所依赖的状态对它的影响相互独立时才能用刷表法。


#### 多阶段决策问题
在回溯法中，每次决策对应于给一个结点产生新的子树，而解的生成过程对应于一个解答树，结点的层数就是“下一个待填充的位置”cur。

多阶段决策问题的最优化问题往往可以用动态规划解决，其中，状态及其转移类似于回溯中的解答树。解答树中的“层数”，也就是递归函数中的“当前填充位置”cur，描述的是即将完成的决策序号，在动态规划中被称为“阶段”。

##### 多段路的最短路

##### 01 背包问题
